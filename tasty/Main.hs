module Main where

import qualified Control.Monad.Except as Except
import qualified Data.Text as Text
import qualified Data.Text.IO as TIO
import qualified Silene
import qualified Silene.Elab as Elab
import qualified Silene.Eval as Eval
import qualified Silene.Parser as Parser
import qualified System.Directory as Directory
import System.FilePath ((</>))
import qualified System.FilePath as FilePath
import Test.Tasty (TestTree)
import qualified Test.Tasty as Tasty
import qualified Test.Tasty.Silver as Silver
import Text.Megaparsec (initialPos)

fileToTestTree :: FilePath -> IO TestTree
fileToTestTree prefix = do
  let input = prefix <> "-input.silene"
  let expectedTypeFile = prefix <> "-type.silene"
  let expectedNfFile = prefix <> "-nf.silene"
  let expectedStderrFile = prefix <> "-stderr.txt"

  let name = FilePath.takeBaseName input

  content <- TIO.readFile input

  case Parser.parseText input content of
    Left parseError ->
      pure
        ( Tasty.testGroup
            name
            [ Silver.goldenVsAction
                (name <> " - error")
                expectedStderrFile
                (return (Text.pack parseError))
                id
            ]
        )
    Right ast ->
      case Except.runExcept
        ( Elab.infer
            (Elab.emptyCtxt (initialPos (Text.unpack content)))
            ast
        ) of
        Left elabError ->
          pure
            ( Tasty.testGroup
                name
                [ Silver.goldenVsAction
                    (name <> " - error")
                    expectedStderrFile
                    ( return
                        ( Text.pack
                            ( Silene.displayError
                                (Text.unpack content)
                                elabError
                            )
                        )
                    )
                    id
                ]
            )
        Right (t, a) -> do
          let quoted = Text.pack $ show $ Eval.quote 0 a
              normalForm = Text.pack $ show $ Eval.nf [] t
              nfFull = normalForm <> "\n  :" <> quoted

          pure
            ( Tasty.testGroup
                name
                [ Silver.goldenVsAction
                    (name <> " - normal form")
                    expectedNfFile
                    (return nfFull)
                    id,
                  Silver.goldenVsAction
                    (name <> " - type")
                    expectedTypeFile
                    (return quoted)
                    id
                ]
            )

inputFileToPrefix :: FilePath -> Maybe FilePath
inputFileToPrefix inputFile =
  fmap Text.unpack (Text.stripSuffix "-input.silene" (Text.pack inputFile))

directoryToTestTree :: FilePath -> IO TestTree
directoryToTestTree directory = do
  let name = FilePath.takeBaseName directory

  children <- Directory.listDirectory directory

  let process child = do
        let childPath = directory </> child

        isDirectory <- Directory.doesDirectoryExist childPath

        if isDirectory
          then do
            testTree <- directoryToTestTree childPath

            return [testTree]
          else do
            case inputFileToPrefix childPath of
              Just prefix -> do
                testTree <- fileToTestTree prefix

                return [testTree]
              Nothing -> do
                return []

  testTrees <- traverse process children

  return (Tasty.testGroup name (concat testTrees))

main :: IO ()
main = do
  autogeneratedTestTree <- directoryToTestTree "tasty/data"
  Tasty.defaultMain (Tasty.testGroup "Tests" [autogeneratedTestTree])
